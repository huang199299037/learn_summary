# JVM

![](jvm\结构.png)

## 内存结构

### 1. 程序计数器

1.1 定义

Program Counter Register 程序计数器（寄存器）

- 作用，是记住下一条jvm指令的执行地址
- 特点
  - 线程私有
  - 不会内存溢出

### 2. 虚拟机栈

- 每个线程运行时所需要的内存，称为虚拟机栈
- 每个栈由多个栈帧组成，对应每次方法调用所占的内存
- 每个线程只能有一个活动栈帧，对应当前正在执行的方法

**问题辨析**

1. 垃圾回收是否涉及栈内存？

   不涉及

2. 栈内存分配越大越好吗？

   不是

3. 方法内的局部变量是否线程安全

  - 如果方法内局部变量没有逃离方法的作用访问，它是线程安全的
  - 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

**栈内存溢出**

- 栈帧过多导致栈内存溢出

- 栈帧过大导致栈内存溢出

**cpu占用过高**

- 用top定位哪个进程对cpu的占用过高
- ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）
  jstack 进程id
- 可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号

### 3. 本地方法栈

调用本地接口

### 4. 堆

Heap 堆

- 通过 new 关键字，创建对象都会使用堆内存
- 特点
  它是线程共享的，堆中对象都需要考虑线程安全的问题
  有垃圾回收机制

**堆内存溢出堆内存诊断**

1. jps 工具
查看当前系统中有哪些 java 进程
2. jmap 工具
查看堆内存占用情况 jmap - heap 进程id
3. jconsole 工具
图形界面的，多功能的监测工具，可以连续监测

### 5. 方法区

![](jvm\方法区.png)

1.8 以前会导致永久代内存溢出

```
演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space
* -XX:MaxPermSize=8m
```

1.8 之后会导致元空间内存溢出

```
演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace
* -XX:MaxMetaspaceSize=8m
```

**运行时常量池**

- 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量
  等信息
- 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量
  池，并把里面的符号地址变为真实地址

StringTable 特性

- 常量池中的字符串仅是符号，第一次用到时才变为对象
- 利用串池的机制，来避免重复创建字符串对象
- 字符串变量拼接的原理是 StringBuilder （1.8）
- 字符串常量拼接的原理是编译期优化
- 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池
  - 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串
    池中的对象返回
  - 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，
    放入串池， 会把串池中的对象返回

### 6. 直接内存

Direct Memory

- 常见于 NIO 操作时，用于数据缓冲区
- 分配回收成本较高，但读写性能高
- 不受 JVM 内存回收管理

分配和回收原理

- 使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法
- ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦
  ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调
  用 freeMemory 来释放直接内存

## 垃圾回收

### 判断对象可回收

- 引用计数法
- 可达性分析
- 四种引用

**引用计数法**

```
如果有地方引用该对象，该对象的引用计数就+1，如果引用失效的话就减一。计数器为0的对象不可以被使用。缺点是无法解决循环引用
```

**可达性分析**

```
如果我们将一些GC Roots对象作为起始点，从这些节点向下搜索，搜索到的路径为引用链，如果有一些对象没有任何引用链相连，那么这个对象对于GC Roots是不可达的，即使它们之间可能相互产生关联，所以将其判定为可回收对象

试想一下，如果有两个对象互相引用，比如objA.instance = objB, objB.instance = objB，这个时候两个对象都不能被访问，但是互相引用导致引用计数不为0，这不就无法判定为死亡了吗？我们如果是GC，能允许这种长生不死的存在吗？肯定不。所以引用计数法并没有被采用在目前的JVM垃圾回收器中。所以jvm使用的是可达性分析法算法

可达性分析算法：通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时（或者该对象不是GCRoot对象时），则认为该对象不可达，后面该对象将会被垃圾收集器回收其所占的内存。

Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以
回收
```

哪些对象可以作为 GC Root ?

  **a.** java虚拟机栈中的引用的对象。 

```
每个方法执行，jvm创建相应的栈帧，
栈帧包括（操作数栈、局部变量表、运行时常量池引用）
栈帧中包含这个方法使用的所有对象引用
一旦方法执行完，该栈帧从虚拟机栈中弹出，这样一来局部对象的引用也就不存在，或者说没有任何GCRoot指向这些临时对象，下一次gc就会被回收
```

  **b**.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）

```
类属性被每个线程共享
```

  **c**.方法区中的常量引用的对象。 

```
赋值之后不可更改，每个线程共享
```

  **d**.本地方法栈中的JNI（native方法）引用的对象

**四种引用**

1. 强引用
只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收
2. 软引用（SoftReference）
仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用
对象
可以配合引用队列来释放软引用自身
3. 弱引用（WeakReference）
仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象
可以配合引用队列来释放弱引用自身
4. 虚引用（PhantomReference）
必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，
由 Reference Handler 线程调用虚引用相关方法释放直接内存
5. 终结器引用（FinalReference）
无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象
暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize
方法，第二次 GC 时才能回收被引用对象

### 垃圾回收算法

**标记清除**

```
优点：速度较快
缺点：不连续，产生内存碎片
```

![](jvm\标记清除.png)

**标记整理**

```
优点：没有内存碎片
缺点：速度慢
```

![](jvm\标记整理.png)

**复制**

```
优点：不会有内存碎片
缺点：需要占用双倍内存空间
```

![](jvm\复制.png)

### 分代垃圾回收

![](jvm\分代.png)

- 对象首先分配在伊甸园区域
- 新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的
  对象年龄加 1并且交换 from to
- minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行
- 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）
- 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时
  间更长