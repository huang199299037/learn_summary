# 垃圾回收

引用计数法

```
每当有一个对象引用时，+1，引用失效是-1，但是无法解决循环引用的情况
```

可达性分析

```java
GCRoot中存在的对象不会被回收，反之会被回收
GCRoot对象包括
1. 虚拟机栈中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(Native方法)引用的对象
```

<img src="java基础\四种GCroot对象.png" style="zoom:67%;" />

四种引用

![](java基础\四种引用.png)

标记清除算法

![](java基础\标记清除.png)

```
产生内存碎片
```

复制算法

<img src="java基础\复制算法.png" style="zoom:67%;" />

```
预留50%的空间，浪费空间
```

标记整理算法

<img src="java基础\标记整理.png" style="zoom:67%;" />

```
首先，要在内存中移动对象，这很慢很低效，并且，在移动时，你还要考虑到并发问题（假如用户线程正在使用你移动的对象怎么办），所以你需要STW，那么此时又更慢了。
```

分带垃圾回收

![](java基础\分带垃圾回收.png)

![](java基础\分带注意.png)

Serial垃圾收集器

![](java基础\serial.png)

ParNew

![](java基础\paranew.png)