# Go学习笔记



## Go概述



### 执行流程分析

```
.go=>go build =>可执行文件=》运行
.=>go run=>运行
```

区别

```
1)如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，仍然可以运行。
2)如果我们是直接go run go源代码，那么如果要在另外一个机器上这么运行，也需要go开发环境，否则无法执行。
3)在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多。
```

### Go程序开发的注意事项

```
1)Go源文件以"go"为扩展名。
2)Go应用程序的执行入口是main()函数。这个是和其它编程语言（比如java/c）
3)Go语言严格区分大小写。
4)Go方法由一条条语句构成，每个语句后不需要分号(Go语言会在每行后自动加分号)，这也体现出Golang的简洁性
5)Go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错
6)go语言定义的变量或者import的包如果没有使用到，代码不能编译通过
7)大括号都是成对出现的，缺一不可
```

### Go语言的转义字符(escapechar)

```
常用的转义字符有如下:
1) \t:表示一个制表符，通常使用它可以排版。
2) \n：换行符
3) \\：一个\ 
4) \"：一个"
5) \r：一个回车fmt.Println("天龙八部雪山飞狐\r张飞"); 张飞八部雪山飞狐(从当前行最前面开始输出，覆盖以前内容)
```

### 规范的代码风格

```
注释
1) Go官方推荐使用行注释来注释整个方法和语句

正确的缩进和空白
1) 使用一次tab操作，实现缩进,默认整体向右边移动，时候用shift+tab整体向左移
2) 或者使用gofmt来进行格式化
3) 运算符两边习惯性各加一个空格。比如：2+4*5
4) Go语言的代码风格.{ 在一行
} 不允许
{
}
5) 一行最长不超过80个字符，超过的请使用换行展示，尽量保持格式优雅
```

## Go变量

### 变量的介绍

1) 变量表示内存中的一个存储区域

2) 该区域有自己的名称（变量名）和类型（数据类型）

Golang变量使用的三种方式

(1) 第一种：指定变量类型，声明后若不赋值，使用默认值

```go
var i int (int 默认值为 0)
```

(2) 第二种：根据值自行判定变量类型(类型推导)

```
var num = 10.11
```

(3) 第三种：省略var,注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误

```
name := "tom"
```

4) 多变量声明

```go
1. var n1, n2, n3 int
2. var n1, n2, n3 = 10, 20, 30
3. n1, n2, n3 := 10, 20, 30
```

如何一次性声明多个全局变量

```go
1. var n1 = 10
var n2 = 20
var n3 = 30
2. var (
    n1 = 10
    n2 = 20
    n3 = 30
)
```

5) 该区域的数据值可以在同一类型范围内不断变化(重点)

```go
var i int = 10
i = 20 true
i = 10.1 false
```

6) 变量在同一个作用域(在一个函数或者在代码块)内不能重名

7) 变量=变量名+值+数据类型，这一点请大家注意，变量的三要素

8) Golang的变量如果没有赋初值，编译器会使用默认值,比如int默认值 0 string默认值为空串，小数默认为 0

### 程序中+号的使用

1) 当左右两边都是数值型时，则做加法运算

2) 当左右两边都是字符串，则做字符串拼接

### 数据类型的基本介绍

![](go学习笔记\基本数据类型.png)

### 整数类型

整型的使用细节

1) Golang各整数类型分：有符号和无符号，int uint的大小和系统有关。

```
是根据操作系统平台而言的,

如果是64位操作系统, 这个int默认是int64
32位操作系统才是int32
```

2) Golang的整型默认声明为int型

3) 如何在程序查看某个变量的字节大小和数据类型（使用较多）

```go
fmt.Printf("n 类型 %T 字节数 %d", n1, unsafe.Sizeof(n))
```

4) Golang程序中整型变量在使用时，遵守保小不保大的原则，即：在保证程序正确运行下，尽量使用占用空间小的数据类型。【如：年龄】byte 0~255 与uint8等价

5) bit:计算机中的最小存储单位。byte:计算机中基本存储单元。[二进制再详细说]1byte=8bit

### 小数类型(float)

```
单精度 float32 4字节
双精度 float64 8字节
```

1) Golang浮点类型有固定的范围和字段长度，不受具体OS(操作系统)的影响

2) Golang的浮点型默认声明为float64类型

3) 浮点型常量有两种表示形式

十进制数形式：如：5.12  .512(必须有小数点）=>0.512

科学计数法形式:如：5.1234e2 = 5.12*10的2次方 5.12E-2 = 5.12/10的2次方

4) 通常情况下，应该使用float64，因为它比float32更精确。[开发中，推荐使用float64]

### 字符类型

```
Golang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用byte来保存。
字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而Go的字符串不同，它是由字节组成的
```

输出

```
fmt.Printf("%c", n)
```

1) 如果我们保存的字符在ASCII表的,比如[0-1,a-z,A-Z..]直接可以保存到byte

2) 如果我们保存的字符对应码值大于255,这时我们可以考虑使用int类型保存

3) 如果我们需要安装字符的方式输出，这时我们需要格式化输出，即fmt.Printf(“%c”,c1)..

4) 在Go中，字符的本质是一个整数，直接输出时，是该字符对应的UTF-8编码的码值

5) Go语言的编码都统一成了utf-8。非常的方便，很统一，再也没有编码乱码的困扰了

### 布尔类型

1) 布尔类型也叫bool类型，bool类型数据只允许取值true和false

2) bool类型占1个字节。

3) bool类型适于逻辑运算，一般用于程序流程控制

### string类型

字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本

1) Go语言的字符串的字节使用UTF-8编码标识Unicode文本，这样Golang统一使用UTF-8编码,中文乱码问题不会再困扰程序员

2) 字符串一旦赋值了，字符串就不能修改了：在Go中字符串是不可变的

3) 字符串的两种表示形式

(1) 双引号,会识别转义字符

(2) 反引号，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码等效果

4) 字符串拼接方式 +

```go
var str = "hello" + "world"
str += "haha"
```

5) 当一行字符串太长时，需要使用到多行字符串，可以如下处理

```go
var str = "hello" + "hello" + (+放末尾)
"hello" true

var str = "hello" + "hello" 
+ "hello" false
```

### 基本数据类型的默认值

在go中，数据类型都有一个默认值，当程序员没有赋值时，就会保留默认值，在go中，默认值又叫零值

| 数据类型 | 默认值 |
| -------- | ------ |
| 整型     | 0      |
| 浮点型   | 0      |
| 布尔     | false  |
| 字符串   | “”     |

### 基本数据类型的相互转换

Golang和java/c不同，Go在不同类型的变量之间赋值时需要显式转换。也就是说Golang中数据类型不能自动转换

表达式T(v)将值v转换为类型T

```go
int=> float
var i = 100
var n float32 = float32(i)
低精度转高精度 和 高精度转低精度都可以
```

1) Go中，数据类型的转换可以是从表示范围小-->表示范围大，也可以范围大--->范围小

2) 被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化！

3) 在转换中，比如将int64转成int8【-128---127】，编译时不会报错，只是转换的结果是按溢出处理，和我们希望的结果不一样。因此在转换时，需要考虑范围

### 基本数据类型和string的转换

**基本类型转string类型**

方式1：fmt.Sprintf("%参数",表达式)【个人习惯这个，灵活】

```go
var num = 99
var str string
str = fmt.Sprintf("%d",num) 浮点型 ("%f",float) 布尔("%t",bool) "q" "true" 
fmt.Printf("%T %v",str,str)
```

方式2：使用strconv包的函数

```go
str = strconv.FormatInt()
```

**string类型转基本数据类型**

使用时strconv包的函数

```
var b , _ = strconv.ParseBool()
```

**string转基本数据类型的注意事项**

在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如我们可以把"123",转成一个整数，但是不能把"hello"转成一个整数，如果这样做，Golang直接将其转成0，其它类型也是一样的道理.float=>0 bool=>false

### 指针

**基本介绍**

1) 基本数据类型，变量存的就是值，也叫值类型

2) 获取变量的地址，用&，比如：varnumint,获取num的地址：&num

![](go学习笔记\指针1.png)

3) 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值

比如：var ptr *int = &num

![](go学习笔记\指针2.png)

4) 获取指针类型所指向的值，使用：*，比如：var ptr  *int,使用 *ptr 获取 ptr 指向的值

**指针的使用细节**

1) 值类型，都有对应的指针类型，形式为*数据类型，比如int的对应的指针就是 *int,float32对应的指针类型就是 *float32,依次类推。

2) 值类型包括：基本数据类型int系列,float系列,bool,string、数组和结构体struct

**值类型和引用类型**

1) 值类型：基本数据类型int系列,float系列,bool,string、数组和结构体struct

2) 引用类型：指针、slice切片、map、管道chan、interface等都是引用类型

**值类型和引用类型的使用特点**

1) 值类型：变量直接存储值，内存通常在栈中分配

2) 引用类型：变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收

3) 内存的栈区和堆区示意图

![](go学习笔记\栈和堆.png)

### 标识符的命名规范

1) Golang对各种变量、方法、函数等命名时使用的字符序列称为标识符

2) 凡是自己可以起名字的地方都叫标识符

**标识符的命名规则**

1) 由26个英文字母大小写，0-9，_组成

2) 数字不可以开头

3) Golang中严格区分大小写

4) 标识符不能包含空格

5) 下划线"_"本身在Go中是一个特殊的标识符，称为空标识符。可以代表任何其它的标识符，但是它对应的值会被忽略(比如：忽略某个返回值)。所以仅能被作为占位符使用，不能作为标识符使用

6) 不能以系统保留关键字作为标识符

**标识符命名注意事项**

1) 包名：保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，不要和标准库不要冲突fmt

2) 变量名、函数名、常量名：采用驼峰法 var stuName string = “tom”

3) **如果变量名、函数名、常量名首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用**(注：可以简单的理解成，首字母大写是公开的，首字母小写是私有的),在golang没有public,private等关键字

## 运算符

1) 算术运算符

2) 赋值运算符

3) 比较运算符/关系运算符

4) 逻辑运算符

5) 位运算符

6) 其它运算符

### 算术运算符

1) 对于除号"/"，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如：x:=19/5,结果是3

2) 当对一个数取模时，可以等价a%b=a-a/b*b，这样我们可以看到取模的一个本质运算。

3) Golang的自增自减只能当做一个独立语言使用时，不能这样使用

```go
var a int 
a = i++ false

i++
a = i true
```

4) Golang的++和--只能写在变量的后面，不能写在变量的前面，即：只有a++ a--没有++a  --a

### 关系运算符

1) 关系运算符的结果都是bool型，也就是要么是true，要么是false

2) 关系运算符组成的表达式，我们称为关系表达式：a>b

### 逻辑运算符

1) &&也叫短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false

2) ||也叫短路或：如果第一个条件为true，则第二个条件不会判断，最终结果为true

### 赋值运算符

**赋值运算符的特点**

1) 运算顺序从右往左

2) 赋值运算符的左边只能是变量,右边可以是变量、表达式、常量值

3) 复合赋值运算符等价于下面的效果

比如：a+=3等价于a=a+3

**面试题**

有两个变量，a和b，要求将其进行交换，但是不允许使用中间变量，最终打印结果

```
a = a + b
b = a - b
a = a - b
```

### 键盘输入语句

1) 导入fmt包

2) 调用fmt包的fmt.Scanln()或者fmt.Scanf()

### 进制

1) 二进制：0,1，满2进1。在golang中，不能直接使用二进制来表示一个整数，它沿用了c的特点。

2) 十进制：0-9，满10进1。

3) 八进制：0-7，满8进1.以数字0开头表示。

4) 十六进制：0-9及A-F，满16进1.以0x或0X开头表示。此处的A-F不区分大小写。

## 程序流程控制

### switch分支控制

1) switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，从上到下逐一测试，直到匹配为止。

2) 匹配项后面也**不需要再加break**

**switch的使用的注意事项和细节**

1) case/switch后是一个表达式(即：常量值、变量、一个有返回值的函数等都可以)

2) case后的各个表达式的值的数据类型，必须和switch的表达式数据类型一致

3) case后面可以带多个表达式，使用逗号间隔。比如case表达式1,表达式2

4) case后面的表达式如果是常量值(字面量)，则要求不能重复

5) case后面不需要带break,程序匹配到一个case后就会执行对应的代码块，然后退出switch，如果一个都匹配不到，则执行default

6) default语句不是必须的

7) switch后也可以不带表达式，类似if--else分支来使用

8) switch后也可以直接声明/定义一个变量，分号结束，不推荐

9) switch穿透-fallthrough，如果在case语句块后增加fallthrough,则会继续执行下一个case，也叫switch穿透(默认只能穿透一层)

10) TypeSwitch：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型

### for循环控制

1) Golang提供for-range的方式，可以方便遍历字符串和数组

```
for index, val := range str {

}
```

如果我们的字符串含有中文，那么传统的遍历字符串方式，就是错误，会出现乱码。原因是传统的对字符串的遍历是按照字节来遍历，而一个汉字在utf8编码是对应3个字节。如何解决需要要将str转成[]rune切片

```
var str1 = "hello"
str2 := []rune(str)
```

### while和do..while的实现

Go语言**没有while和do...while语法**，这一点需要同学们注意一下，如果我们需要使用类似其它语言(比如java/c的while和do...while)，可以通过for循环来实现其使用效果

### Break

(1) break默认会跳出最近的for循环

2) break后面可以指定标签，跳出标签对应的for循环

```
label:
for {
 break label
}
```

### Continue

continue语句用于结束本次循环，继续执行下一次循环。continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环,这个和前面的break标签的使用的规则一样.

### Goto

1) Go语言的goto语句可以无条件地转移到程序中指定的行。

2) goto语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。

3) 在Go程序设计中一般**不主张使用goto语句**，以免造成程序流程的混乱，使理解和调试程序都产生困难

goto label

...

label: 

statemen

### Return

1) 如果return是在普通的函数，则表示跳出该函数，即不再执行函数中return后面代码，也可以理解成终止函数。

2) 如果return是在main函数，表示终止main函数，也就是说终止程序

## 函数、包和错误处理

### 函数定义

func 函数名（形参列表）(返回值列表){

执行语句

return 返回值列表

}

### 函数使用的注意事项和细节讨论

1) Go函数不支持函数重载

2) 在Go中，函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用

3) 函数既然是一种数据类型，因此在Go中，函数可以作为形参，并且调用

### init函数

**基本介绍**

每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用

**inti函数的注意事项和细节**

1) 如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程全局变量定义->init函数->main函数

2) init函数最主要的作用，就是完成一些初始化的工作

3) 细节说明:面试题：案例如果main.go和utils.go都含有变量定义，init函数时，执行的流程又是怎么样的呢

![](go学习笔记\init.png)

### 匿名函数

**介绍**

Go支持匿名函数，匿名函数就是没有名字的函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用

**匿名函数使用方式**

1）在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次

2）将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数

### 闭包

基本介绍：闭包就是一个函数和与其相关的引用环境组合的一个整体(实体)

### 函数的defer

在函数中，程序员经常需要创建资源(比如：数据库连接、文件句柄、锁等)，为了在函数执行完毕后，及时的释放资源，Go的设计者提供defer(延时机制)

1) 当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中[我为了讲课方便，暂时称该栈为defer栈],然后继续执行函数下一个语句

2) 当函数执行完毕后，在从defer栈中，依次从栈顶取出语句执行(注：遵守栈先入后出的机制)

3) 在defer将语句放入到栈时，也会将相关的值拷贝同时入栈

### 函数参数传递方式

1) 值传递

2) 引用传递

其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低

**值类型和引用类型**

1) 值类型：基本数据类型int系列,float系列,bool,string、数组和结构体struct

2) 引用类型：指针、slice切片、map、管道chan、interface等都是引用类型

3) 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，函数内以指针的方式操作变量。从效果上看类似引用。

### 变量作用域

1) 函数内部声明/定义的变量叫局部变量，作用域仅限于函数内部

2) 函数外部声明/定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用域在整个程序有效

3) 如果变量是在一个代码块，比如for/if中，那么这个变量的的作用域就在该代码块

### 字符串常用的系统函数

1) 统计字符串的长度，按字节len(str) （golang同意utf-8编码，字母和数字一个字节，汉字占三个字节）

2) 字符串遍历，同时处理有中文的问题r:=[]rune(str)

3) 字符串转整数:n,err:=strconv.Atoi("12")

4) 整数转字符串str=strconv.Itoa(12345)

5) 字符串转[]byte: varbytes = []byte("hello go")

6) []byte转字符串:str=string([]byte{97,98,99})

7)10进制转2,8,16进制:str=strconv.FormatInt(123,2)//2->8,16

8) 查找子串是否在指定的字符串中:strings.Contains("seafood","foo")//true

9) 统计一个字符串有几个指定的子串：strings.Count("ceheese","e")//4

10) 不区分大小写的字符串比较(==是区分字母大小写的):fmt.Println(strings.EqualFold("abc","Abc"))//true

11) 返回子串在字符串第一次出现的index值，如果没有返回-1:strings.Index("NLT_abc","abc")//4

12)返回子串在字符串最后一次出现的index，如没有返回-1:strings.LastIndex("gogolang","go") //3

13) 将指定的子串替换成另外一个子串:strings.Replace("gogohello","go","go语言",n)n可以指定你希望替换几个，如果n=-1表示全部替换

14) 按照指定的某个字符，为分割标识，将一个字符串拆分成**字符串数组**：strings.Split("hello,wrold,ok",",")

15) 将字符串的字母进行大小写的转换:strings.ToLower("Go")//go strings.ToUpper("Go")//GO

16) 将字符串左右两边的空格去掉：strings.TrimSpace("   nalon  egoph  erntrn  ")

17) 将字符串左右两边指定的字符去掉：strings.Trim("! hello! "," !")//将左右两边!和""去掉

18) 将字符串左边指定的字符去掉：strings.TrimLeft("! hello! ","! ")//将左边!和""去掉

19) 将字符串右边指定的字符去掉：strings.TrimRight("! hello! ","!")//将右边!和""去掉

20) 判断字符串是否以指定的字符串开头:strings.HasPrefix("ftp://192.168.10.1","ftp")//true

21) 判断字符串是否以指定的字符串结束:strings.HasSuffix("NLT_abc.jpg","abc")//false

### 时间和日期相关函数

1) 时间和日期相关函数，需要导入time包

2) time.Time类型，用于表示时间

```go
now := time.now()
now.Year()
```

3) 格式化日期时间

方式1:就是使用Printf或者SPrint

方式2:使用time.Format()方法完成:

"2006/01/02 15:04:05"这个字符串的各个数字是固定的，必须是这样写。"2006/01/02 15:04:05"这个字符串各个数字可以自由的组合，这样可以按程序需求来返回时间和日期

4) 时间的常量

```
const(
Nanosecond Duration=1//纳秒
Microsecond=1000*Nanosecond //微秒
Millisecond=1000*Microsecond //毫秒
Second=1000*Millisecond/ /秒
Minute=60*Second //分钟
Hour=60*Minute //小时
)
```

常量的作用:在程序中可用于获取指定时间单位的时间，比如想得到100毫秒100*time.Millisecond

5) time的Unix和UnixNano的方法

```
Unix时间戳 秒
UnixNano时间戳 纳秒

```

### 内置函数

1) len：用来求长度，比如string、array、slice、map、channel

2) new：用来分配内存，主要用来分配值类型，比如int、float32,struct...返回的是指针

3) make：用来分配内存，主要用来分配引用类型，比如channel、map、slice。

### 错误处理

1) Go语言追求简洁优雅，所以，Go语言不支持传统的try...catch...finally这种处理。

2) Go中引入的处理方式为：defer,panic,recover

3) 这几个异常的使用场景可以这么简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理

### 自定义错误

Go程序中，也支持自定义错误，使用errors.New和panic内置函数。

1) errors.New("错误说明"),会返回一个error类型的值，表示一个错误

2) panic内置函数,接收一个interface{}类型的值（也就是任何值了）作为参数。可以接收error类型的变量，输出错误信息，并退出程序.

## 数组与切片

### 数组定义和内存布局

**数组的定义**

var 数组名 [数组大小]数据类型

var a [5]int 赋初值 a[0]=1a[1]=30....

**数组在内存布局(重要)**

1) 数组的地址可以通过数组名来获取 &intArr

2) 数组的第一个元素的地址，就是数组的首地址

3) 数组的各个元素的地址间隔是依据数组的类型决定，比如 int64->8 int32->4

### 数组使用的注意事项和细节

初始化数组

![](go学习笔记\数组初始化.png)

1) 数组是多个相同类型数据的组合,一个数组一旦声明/定义了,其长度是固定的,不能动态变化

2) var arr []int这时arr就是一个slice切片

3) 数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能混用

4) 数组创建后，如果没有赋值，有默认值(零值)

数值类型数组：默认值为0

字符串数组：默认值为""

bool数组：默认值为false

5) 长度是数组类型的一部分，在传递函数参数时需要考虑数组的长度

### 切片

**切片的使用**

第一种方式：定义一个切片，然后让切片去引用一个已经创建好的数组

第二种方式：通过make来创建切片.基本语法：var切片名[]type=make([]type,len,[cap])

参数说明:type:就是数据类型len:大小cap：指定切片容量，可选，如果你分配了cap,则要求cap>=len

1) 通过make方式创建切片可以指定切片的大小和容量

2) 如果没有给切片的各个元素赋值，那么就会使用默认值[int,float=>0string=>””bool=>false]

3) 通过make方式创建的切片对应的数组是由make底层维护，对外不可见，即只能通过slice去访问各个元素

第三种方式：定义一个切片，直接就指定具体数组，使用原理类似make的方式

**切片的使用的注意事项和细节讨论**

1) 用append内置函数，可以对切片进行动态追加

**切片append操作的底层原理分析**:

切片append操作的本质就是对数组扩容

go底层会创建一下新的数组newArr(安装扩容后大小)

将slice原来包含的元素拷贝到新的数组newArr

slice重新引用到newArr

注意newArr是在底层来维护的，程序员不可见

2）切片的拷贝操作

(1) copy(para1,para2)参数的数据类型是切片

(2) 按照上面的代码来看,slice4和slice5的数据空间是独立，相互不影响

### string和slice

1) string底层是一个byte数组，因此string也可以进行切片处理

2) string是不可变的，也就说不能通过str[0]='z'方式来修改字符串

3) 如果需要修改字符串，可以先将string->[]byte切片或者[]rune-切片>修改->重写转成string

![](go学习笔记\string修改.png)

## 排序和查找

### 二维数组

**先声明/定义,再赋值**

语法:var 数组名  [大小] [大小]类型 

再赋值

**直接初始化**

声明：var 数组名 [大小] [大小]类型 = [大小] [大小] 类型 {{初值..},{初值..}}

## Map

### 基本语法

var map 变量名 map[keytype]valuetype

key可以是什么类型

golang中的map，的key可以是很多种类型，比如bool,数字，string,指针,channel,还可以是只包含前面几个类型的接口,结构体,数组

通常key为int、string

注意:slice，map还有function不可以，因为这几个没法用==来判断

valuetype 可以是什么类型valuetype的类型和key基本一样

通常为:数字(整数,浮点数),string,map,struct

**map声明的举例：**

var a map[string]string

var a map[string]int

var a map[int]string

var a map[string]map[string]string

注意：声明是不会分配内存的，初始化需要make，分配内存后才能赋值和使用

### map的增删改查操作

**map增加和更新：**

map["key"]=value//如果key还没有，就是增加，如果key存在就是修改

**map删除：**

说明：delete(map，"key")，delete是一个内置函数，如果key存在，就删除该key-value,如果key不存在，不操作，但是也不会报错

细节说明

如果我们要删除map的所有key,没有一个专门的方法一次删除，可以遍历一下key,逐个删除或者map=make(map[string]string)，make一个新的，让原来的成为垃圾，被gc回收

**map查找:**

val,error := map[“key”]

### map切片

切片的数据类型如果是map，则我们称为slice of map，map切片，这样使用则map个数就可以动态变化了

### map排序

**基本介绍**

1) golang中没有一个专门的方法针对map的key进行排序

2) golang中的map默认是无序的，注意也不是按照添加的顺序存放的，你每次遍历，得到的输出可能不一样.

3) golang中map的排序，是先将key进行排序，然后根据key值遍历输出即可

### map使用细节

1) map是引用类型，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的map

2) map的容量达到后，再想map增加元素，会自动扩容，并不会发生panic，也就是说map能动态的增长键值对(key-value)

3) map的value也经常使用struct类型，更适合管理复杂的数据(比前面value是一个map更好)

## 面向对象编程

### 结构体

1) Golang也支持面向对象编程(OOP)，但是和传统的面向对象编程有区别，并不是纯粹的面向对象语言。所以我们说Golang支持面向对象编程特性是比较准确的。

2) Golang没有类(class)，Go语言的结构体(struct)和其它编程语言的类(class)有同等的地位，你可以理解Golang是基于struct来实现OOP特性的。

3) Golang面向对象编程非常简洁，去掉了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等等

4) Golang仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式和其它OOP语言不一样，比如继承：Golang没有extends关键字，继承是通过匿名字段来实现。

5) Golang面向对象(OOP)很优雅，OOP本身就是语言类型系统(typesystem)的一部分，通过接口(interface)关联，耦合性低，也非常灵活。后面同学们会充分体会到这个特点。也就是说在Golang中面向接口编程是非常重要的特性

**结构体和结构体变量(实例)的区别和联系**

1) 结构体是自定义的数据类型，代表一类事物.

2) 结构体变量(实例)是具体的，实际的，代表一个具体变量

**如何声明结构体**

基本语法 

type 结构体名称 struct{

field1 type 

field2 type

}

1) 指针，slice，和map的零值都是nil，即还没有分配空间。

2) 不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个,结构体是值类型

**创建结构体变量和访问结构体字段**

方式1 直接声明案例演示:var person Person

方式2-{} 案例演示:var person Person=Person{}

方式3-& 案例:var person *Person=new(Person)

方式4-{} 案例:var person *Person=&Person{}

**说明:**

1) 第3种和第4种方式返回的是结构体指针。

2) 结构体指针访问字段的标准方式应该是：(* 结构体指针).字段名，比如(*person).Name="tom"

3) 但go做了一个简化，也支持结构体指针.字段名,比如person.Name="tom"。更加符合程序员使用的习惯，go编译器底层对person.Name做了转化(*person).Name

**结构体使用注意事项和细节**

1) 结构体的所有字段在内存中是连续的

2) 结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段(名字、个数和类型)

3) 结构体进行type重新定义(相当于取别名)，Golang认为是新的数据类型，但是相互间可以强转

4) struct的每个字段上，可以写上一个tag,该tag可以通过反射机制获取，常见的使用场景就是序列化和反序列化

```go
type name struct{
Name string `json:"name"`
Age int `json:"age"`
}
```

### 方法

Golang中的方法是作用在指定的数据类型上的(即：和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是struct

**方法的声明和调用**

```go
type A struct{
    Num
    int
}
func(a A) test(){
    fmt.Println(a.Num)
}
```

对上面的语法的说明

1) func(a A) test(){}表示A结构体有一方法，方法名为test

2) (a A)体现test方法是和A类型绑定的

**总结**

1) test方法和Person类型绑定

2) test方法只能通过Person类型的变量来调用，而不能直接调用，也不能使用其它类型变量来调用

3) func(p Person) test(){}...p表示哪个Person变量调用，这个p就是它的副本,这点和函数传参非常相似

4) p这个名字，有程序员指定，不是固定,比如修改成person也是可以

**方法的调用和传参机制原理**

说明:

1) 在通过一个变量去调用方法时，其调用机制和函数一样

2) 不一样的地方时，变量调用方法时，该变量本身也会作为一个参数传递到方法(如果变量是值类型，则进行值拷贝，如果变量是引用类型，则进行地质拷贝)

3) 结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式

4) 如程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理

5) Golang中的方法作用在指定的数据类型上的(即：和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是struct，比如int,float32等都可以有方法

6) 方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其它包访问

7) 如果一个类型实现了String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出

**方法和函数区别**

1) 调用方式不一样

函数的调用方式: 函数名(实参列表)

方法的调用方式: 变量.方法名(实参列表)

2) 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然

3) 对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以

**总结:**

1) 不管调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定.

2) 如果是和值类型，比如(pPerson),则是值拷贝，如果和指针类型，比如是(p*Person)则是地址拷贝

### 工厂模式

**说明**

Golang的结构体没有构造函数，通常可以使用工厂模式来解决这个问题

### 封装

1) 对结构体中的属性进行封装

2) 通过方法，包实现封装

### 继承

在Golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性

```go
嵌套匿名结构体的基本语法
type Goods struct{
Name string
Price int
}
type Book struct{
Goods//这里就是嵌套匿名结构体Goods
Writer string
}
```

**讨论**

1) 结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者小写的字段、方法，都可以使用

2) 匿名结构体字段访问可以简化

```
(1)当我们直接通过b访问字段或方法时，其执行流程如下比如b.Name
(2)编译器会先看b对应的类型有没有Name,如果有，则直接调用B类型的Name字段
(3)如果没有就去看B中嵌入的匿名结构体A有没有声明Name字段，如果有就调用,如果没有继续查找..如果都找不到就报错
```

3) 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分

4) 结构体嵌入两个(或多个)匿名结构体，如两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，在访问时，就必须明确指定匿名结构体名字，否则编译报错

5) 如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字

6) 嵌套匿名结构体后，也可以在创建结构体变量(实例)时，直接指定各个匿名结构体字段的值

说明

1) 如果一个结构体有int类型的匿名字段，就不能第二个。

2) 如果需要有多个int的字段，则必须给int字段指定名字

**多重继承**

```
如一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承
```

### 接口

```
interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。到某个自定义类型(比如结构体Phone)要使用的时候,在根据具体情况把这些方法写出来(实现)。
```

**基本语法**

```go
type 接口名 interface{
    method1(参数列表) 返回值列表
    method2(参数列表) 返回值列表
}
实现所有方法
```

1) 接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚低偶合的思想。

2) Golang中的接口，不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。因此，Golang中没有implement这样的关键字

**注意事项和细节**

1) 接口本身不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量(实例)

2) 接口中所有的方法都没有方法体,即都是没有实现的方法。

3) 在Golang中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现了该接口。

4) 一个自定义类型只有实现了某个接口，才能将该自定义类型的实例(变量)赋给接口类型

5) 只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型

6) 一个自定义类型可以实现多个接口

7) Golang接口中不能有任何变量

8) 一个接口(比如A接口)可以继承多个别的接口(比如B,C接口)，这时如果要实现A接口，也必须将B,C接口的方法也全部实现

9) interface类型默认是一个指针(引用类型)，如果没有对interface初始化就使用，那么会输出nil

10) 空接口interface{}没有任何方法，所以所有类型都实现了空接口,即我们可以把任何一个变量赋给空接口

**接口vs继承**

1) 当A结构体继承了B结构体，那么A结构就自动的继承了B结构体的字段和方法，并且可以直接使用

2) 当A结构体需要扩展功能，同时不希望去破坏继承关系，则可以去实现某个接口即可，因此我们可以认为：实现接口是对继承机制的补充

接口和继承解决的解决的问题不同

继承的价值主要在于：解决代码的复用性和可维护性。

接口的价值主要在于：设计，设计好各种规范(方法)，让其它自定义类型去实现这些方法。

接口比继承更加灵活Person Student BirdAble LittleMonkey接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足like-a的关系

接口在一定程度上实现代码解耦

### 多态

变量(实例)具有多种形态。面向对象的第三大特征，在Go语言，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态

**接口体现多态的两种形式**

```
多态参数 在前面的Usb接口案例，Usbusb，即可以接收手机变量，又可以接收相机变量，就体现了Usb接口多态。
多态数组 演示一个案例：给Usb数组中，存放Phone结构体和Camera结构体变量
```

### 类型断言

类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言  xx.(类型)

如何在进行断言时，带上检测机制，如果成功就ok,否则也不要报panic

```go
var x interface
var b float32=1.1
x=b
y,ok:=x.(float32)
if ok==true{
    
}else{
    
}
```

## 文件操作

```
输入流 文件到内存 读文件
输出流 内存到内存 写文件
```

## 单元测试

### 传统方法的缺点分析

1) 不方便,我们需要在main函数中去调用，这样就需要去修改main函数，如果现在项目正在运行，就可能去停止项目。

2) 不利于管理，因为当我们测试多个函数或者多个模块时，都需要写在main函数，不利于我们管理和清晰我们思路

3) 引出单元测试。->testing测试框架可以很好解决问题

### 单元测试-基本介绍

Go语言中自带有一个轻量级的测试框架testing和自带的gotest命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。通过单元测试，可以解决如下问题

1) 确保每个函数是可运行，并且运行结果是正确的 

2) 确保写出来的代码性能是好的，

3) 单元测试能及时的发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定

### 单元测试快速入门总结

1) 测试用例文件名必须以_test.go结尾。比如cal_test.go,cal不是固定的。

2) 测试用例函数必须以Test开头，一般来说就是Test+被测试的函数名，比如TestAddUpper

3)TestAddUpper(t * tesing.T)的形参类型必须是*testing.T

4) 一个测试用例文件中，可以有多个测试用例函数，比如TestAddUpper、TestSub

5) 运行测试用例指令

(1)cmd>go test 如果运行正确，无日志，错误时，会输出日志

(2)cmd>go test -v [运行正确或是错误，都输出日志]

6) 当出现错误时，可以使用t.Fatalf来格式化输出错误信息，并退出程序

7) t.Logf方法可以输出相应的日志

8) 测试用例函数，并没有放在main函数中，也执行了，这就是测试用例的方便之处[原理图].

9) PASS表示测试用例运行成功，FAIL表示测试用例运行失败

10) 测试单个文件，一定要带上被测试的原文件

go test -v cal_test.go cal.go

11) 测试单个方法

go test -v -test.run TestAddUppe

## goroutine和channel

### goroutine-基本介绍

**Go协程和Go主线程**

Go主线程(有程序员直接称为线程/也可以理解成进程):一个Go线程上，可以起多个协程，你可以这样理解，协程是轻量级的线程[编译器做优化

Go协程的特点

1) 有独立的栈空间

2) 共享程序堆空间

3) 调度由用户控制

4) 协程是轻量级的线程

### goroutine-快速入门

1) 主线程是一个物理线程，直接作用在cpu上的。是重量级的，非常耗费cpu资源。

2) 协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小。

3) Golang的协程机制是重要的特点，可以轻松的开启上万个协程。其它编程语言的并发机制是一般基于线程的，开启过多的线程，资源耗费大，这里就突显Golang在并发上的优势了

### goroutine的调度模型

**MPG模式基本介绍**

![](go学习笔记\mpg.png)

**MPG模式运行的状态1**

![](go学习笔记\mpg1.png)

**MPG模式运行的状态2**

![](go学习笔记\mpg2.png)

### 设置Golang运行的cpu数

```go
获取cpu个数
numCPU := runtime.NumCPU()
预留cpu个数 预留一个
fmt.Println(numCPU)
```

### channel(管道)

1) channel本质就是一个数据结构-队列

2) 数据是先进先出【FIFO:firstinfirstout】

3) 线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的

4) channel有类型的，一个string的channel只能存放string类型数据

**定义/声明channel**

var 变量名 chan 数据类型

var intChan chan int(intChan用于存放int数据)

var mapChan chan map[int]string(mapChan用于存放map[int]string类型)

var perChan chan Person

var perChan2 chan *Person

```
channel是引用类型channel必须初始化才能写入数据,即make后才能使用管道是有类型的，intChan只能写入整数int
```

```go
//演示一下管道的使用
//1.创建一个可以存放3个int类型的管道
var intChan chan int
intChan=make(chanint,3)
//2.看看intChan是什么
fmt.Printf("intChan的值=%vintChan本身的地址=%p\n",intChan,&intChan)
//3.向管道写入数据
intChan<-10
num:=211
intChan<-num
intChan<-50
//intChan<-98 //注意点,当我们给管写入数据时，不能超过其容量
//4.看看管道的长度和cap(容量)
fmt.Printf("channellen=%vcap=%v\n",len(intChan),cap(intChan))//3,3
//5.从管道中读取数据
var num2 int
num2=<-intChan
fmt.Println("num2=",num2)
fmt.Printf("channellen=%vcap=%v\n",len(intChan),cap(intChan))//2,3
//6.在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告deadlock
num3:=<-intChan
num4:=<-intChan
num5:=<-intChan
fmt.Println("num3=",num3,"num4=",num4,"num5=",num5)
```

**channel使用的注意事项**

1) channel中只能存放指定的数据类型

2) channle的数据放满后，就不能再放入了

3) 如果从channel取出数据后，可以继续放入

4) 在没有使用协程的情况下，如果channel数据取完了，再取，就会报deadlock

![](go学习笔记\类型断言.png)

### channel的遍历和关闭

**channel的关闭**

使用内置函数close可以关闭channel,当channel关闭后，就不能再向channel写数据了，但是仍然可以从该channel读取数据

```java
intChain := make(chan int,4)
	intChain<-100
	intChain<-200
	close(intChain)

	//出错
	//intChain<-300
	num := <-intChain
	fmt.Print(num)
```

**channel的遍历**

channel支持for--range的方式进行遍历，请注意两个细节

1) 在遍历时，如果channel没有关闭，则回出现deadlock的错误

2) 在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历

```go
close(intChan)
for value := range intChan {
	fmt.Println(value)
}
```

### channel使用细节和注意事项

1) channel可以声明为只读，或者只写性质

```
var intChan chan<- int	(只写)
var intChan2 <-chan (只读)
```

2) 使用select可以解决从管道取数据的阻塞问题

```go
for {
		select {
		//注意:这里，如果intChan一直没有关闭，不会一直阻塞而deadlock
		// ，会自动到下一个case匹配
		 case v:=<-intChan:
		 	fmt.Printf("从intChan读取的数据%d\n",v)
		 	time.Sleep(time.Second)
		 case v:=<-stringChan:
		 	fmt.Printf("从stringChan读取的数据%s\n",v)
		 	time.Sleep(time.Second)
		 default:fmt.Printf("都取不到了，不玩了,程序员可以加入逻辑\n")
		 	time.Sleep(time.Second)
		 return
		 //break label
		 }
	}
```

3) goroutine中使用defer+recover，解决协程中出现panic，导致程序崩溃问题

## 反射

### 基本介绍

1) 反射可以在运行时动态获取变量的各种信息,比如变量的类型(type)，类别(kind)

2) 如果是结构体变量，还可以获取到结构体本身的信息(包括结构体的字段、方法)

3) 通过反射，可以修改变量的值，可以调用关联的方法。

4) 使用反射，需要import(“reflect”)

### 反射的注意事项和细节

1) reflect.Value.Kind，获取变量的类别，返回的是一个常量

2) Type和Kind的区别

Type是类型,Kind是类别，Type和Kind可能是相同的，也可能是不同的.

比如:var num int=10 num的Type是int,Kind也是int

比如:var stu Student stu的Type是pkg1.Student,Kind是struct

3) 通过反射的来修改变量,注意当使用SetXxx方法来设置需要通过对应的指针类型来完成,这样才能改变传入的变量的值,同时需要使用到reflect.Value.Elem()方法

## tcp编程

### 网络编程基本介绍

网络编程有两种:

1) TCP socket编程，是网络编程的主流。之所以叫Tcp socket编程，是因为底层是基于Tcp/ip协议的.比如:QQ聊天[示意图]

2) b/s结构的http编程，我们使用浏览器去访问服务器时，使用的就是http协议，而http底层依旧是用tcpsocket实现的